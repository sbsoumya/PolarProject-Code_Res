# -*- coding: utf-8 -*-
# Copyright 2014-2015 Michael Helmling
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation
#

from __future__ import division, print_function
from collections import OrderedDict
import numpy as np
from lpdec.codes import nonbinary
from lpdec.persistence import JSONDecodable


class Channel(JSONDecodable):
    """Abstract parent class for a communication channel; in fact, instances model the combination
    of modulator and noisy channel. This means that the inputs are unmodulated codewords, while the
    output consists of zero-based log-likelihood ratio (LLR) values, defined as :math:`\\log\\frac{
    P(y|x=0)}{P(y|x=s)}` for the non-zero input symbol :math:`s` and channel observation :math:`y`.

    Channel noise can be generated by calling the :class:`Channel` object with a codeword as
    parameter.

    Parameters
    ----------
    seed : int, optional
        Optional initial random seed value for noise generation.
    q : int, optional
        The arity of the used code. Defaults to 2 for binary codes.

    Attributes
    ----------
    snr : float
        A numerical parameter corresponding to the signal-to-noise ratio of the
        channel. It is not necessarily the "real" SNR, but be chosen such that an increase
        indicates decreasing error probability. This is used for plots and statistics.
    """

    def __init__(self, seed=None, q=2):
        JSONDecodable.__init__(self)
        self.seed = seed
        self.random = None
        self.q = q
        self.signals = np.empty((q, 2))
        for k in range(q):
            self.signals[k] = np.cos(2*np.pi*k/q), np.sin(2*np.pi*k/q)
        self.resetSeed()

    def resetSeed(self):
        """Reset the random seed of the channel to its initial value.

        """
        self.random = np.random.RandomState(self.seed)

    def modulate(self, codeword):
        if self.q == 2:
            return 1 - 2*codeword
        else:
            out = np.empty(codeword.size * 2)
            for i in range(codeword.size):
                out[2*i:2*i+2] = self.signals[codeword[i]]
            return out

    def simulate(self, codeword):
        """Afflict the given input codeword with channel noise.

        Parameters
        ----------
        codeword : numpy array (1-dim)
            The codeword for which the channel transmission is to be simulated.

        Returns
        -------
        numpy array (1-dim)
            Channel output as double array.
        """
        raise NotImplementedError()

    def skip(self, word, num):
        """Skip a given number of simulated transmissions of a given codeword.

        Use this method to resume computations with a given random number seed.

        Parameters
        ----------
        num : int
            Number of transmissions to skip.
        word
            The codeword to use.
        """
        for i in range(num):
            self.simulate(word)

    def __call__(self, codeword):
        return self.simulate(codeword)

    def signalGenerator(self, code, **kwargs):
        """Convenience function returning a :class:`SignalGenerator` for this channel and the
        given `code`.

        Additional keyword args are passed to the :class:`SignalGenerator` constructor.
        """
        return SignalGenerator(code, self, **kwargs)


class AWGNC(Channel):
    """The additive white Gaussian noise channel with q-PSK modulation.

    Parameters
    ----------
    snr : float
        Signal-to-noise ratio :math:`\\frac{E_b}{N_0}` in dB.
    coderate : float
        Coding rate (needed to calculate :math:`E_c` from :math:`E_b`).
    round : int, optional
        Number of decimals to which the resulting LLR values are rounded.
    """

    def __init__(self, snr, coderate, q=2, round=None, seed=None):
        Channel.__init__(self, seed, q)
        self.snr = float(snr)
        self.coderate = coderate
        if q == 2:
            # in this case, the LLRs are iid with N(4 r SNR, 8 r SNR)
            self.llrVariance = 8 * coderate * 10 ** (snr / 10)
            self.llrMean = 4 * coderate * 10 ** (snr / 10)
            self.llrSigma = np.sqrt(self.llrVariance)
        else:
            N0 = 1 / (coderate * 10 ** (snr / 10))
            self.pskSigma = np.sqrt(N0/2)
            self.llrFactor = coderate * 10 ** (snr / 10)

        self.round = round

    def simulate(self, codeword):
        modulated = self.modulate(codeword)
        if self.q == 2:
            llrs = self.random.normal(self.llrMean, self.llrSigma, modulated.shape) * modulated
        else:
            q = self.q
            out = modulated + self.random.normal(0, self.pskSigma, modulated.shape)
            llrs = np.empty(codeword.size * (self.q - 1))
            zero = self.signals[0]
            for i in range(codeword.size):
                y0 = out[2*i]
                y1 = out[2*i+1]
                # yVs0 = np.dot(y-zero, y-zero)
                yVs0 = (y0-1)**2 + y1**2
                for k in range(1, q):
                    #yVsk = np.dot(y-self.signals[k], y-self.signals[k])
                    yVsk = (y0-self.signals[k, 0])**2 + (y1 - self.signals[k, 1])**2
                    llrs[i*(q-1) + k - 1] = self.llrFactor*(yVsk - yVs0)
        if self.round is not None:
            return np.around(llrs, self.round)
        return llrs

    def skip(self, word, num):
        modulated = self.modulate(word)
        if self.q == 2:
            for _ in range(num):
                self.random.normal(self.llrMean, self.llrSigma, modulated.shape)
        else:
            for _ in range(num):
                self.random.normal(0, self.pskSigma, modulated.shape)

    def params(self):
        parms = OrderedDict([('snr', self.snr), ('coderate', self.coderate)])
        if self.q != 2:
            parms['q'] = self.q
        if self.round is not None:
            parms['round'] = self.round
        if self.seed is not None:
            parms['seed'] = self.seed
        return parms


class BSC(Channel):
    """The binary symmetric channel: Indepentently flips each bit with a fixed probability.

    Parameters
    ----------
    p : float
        Crossover probability (:math:`0 \leq p \leq \\frac 1 2`)

    """

    def __init__(self, p, seed=None):
        assert p <= 0.5 and p >= 0
        Channel.__init__(self, seed, q=2)
        self.p = p
        self.snr = 1 - p

    def simulate(self, codeword):
        noise = self.random.random_sample(codeword.shape) < self.p
        noisy = np.logical_xor(codeword, noise)
        return (1-2*noisy)*np.log((1-self.p)/self.p)

    def params(self):
        ans = OrderedDict(p=self.p)
        if self.seed is not None:
            ans['seed'] = self.seed
        return ans


class SignalGenerator(object):
    """An iterator class for generating noisy channel output of transmitted codewords.

    Codewords are sent through a channel which adds noise. A random seed may be provided that is
    used for generating codewords.

    The :class:`SignalGenerator` can be used as an iterator; every call to :func:`next` will yield
    another noisy signal. Afterwards, the attributes :attr:`codeword`  and :attr:`llrOutput` are
    available.

    Parameters
    ----------
    code : :class:`BinaryLinearBlockCode`
        The code to use for generating codewords and deducing block length.
    channel : :class:`.Channel`
        The channel model.
    wordSeed : int, optional
        Random seed for generating codewords. The default value of ``None`` uses a random seed, i.e.
        non-deterministic behavior. The special value ``-1`` causes the zero codeword to be used
        instead of random ones.

    Attributes
    ----------
    llrOutput : np.ndarray[np.double]
        Log-likelihood vector of channel outputs resulting from the most recent simulation.
    codeword : np.ndarray[int]
        The codeword used for the most recent simulation.
    """
    def __init__(self, code, channel, wordSeed=None):
        self.code = code
        self.channel = channel
        self.allZero = (wordSeed == -1)
        self.llrOutput = self.codeword = None
        if self.allZero:
            self.codeword = np.zeros(code.blocklength, dtype=np.int)
        else:
            self.wordSeed = wordSeed
            self.wordRandom = np.random.RandomState(wordSeed)

    def __iter__(self):
        return self

    def next(self):
        """Generate and return the next noisy signal."""
        return self.__next__()

    def skip(self, num):
        """Skip the next `num` signals. When resuming a seeded computation, this is much more
        efficient than calling :func:`next` `num` times for simulation with random codewords, as the
        generation of random words is not actually performed.
        """
        zero = np.zeros(self.code.blocklength, dtype=np.int)
        if not self.allZero:
            for _ in range(num):
                self.wordRandom.randint(0, 2, self.code.infolength)
        self.channel.skip(zero, num)
    
    def __next__(self):
        if not self.allZero:
            self.infoWord = self.wordRandom.randint(0, 2, self.code.infolength)
            self.codeword = self.code.encode(self.infoWord)
        self.llrOutput = self.channel(self.codeword)
        return self.llrOutput

    def correctObjectiveValue(self):
        """Returns the objective value (scalar product of :attr:`llrOutput` and
        :attr:`codeword`) of the codeword that was actually sent.
        """
        if self.channel.q == 2:
            return np.dot(self.codeword, self.llrOutput)
        else:
            return np.dot(nonbinary.flanaganEmbedding(self.codeword, self.channel.q),
                          self.llrOutput)

